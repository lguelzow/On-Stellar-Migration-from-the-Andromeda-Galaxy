# new version of program for my paper

# Main simulation file!
# It reads the data generated by 'M31-trajectory.txt' and 'RNG_initial_conditions.txt'
# and uses them in the calculation of the HVS trajectories.
# The file establishes all tools needed by ODEint for solving the differential equations
# and afterwards filters the results and transforms them to Galactic coordinates
# in the heliocentric rest frame.
# The results are written into two separate result files "present-time-distances.txt"
# and "minimum-time-distances.txt" for data for stars at present time and
# for data for stars at their minimum distance to the MW centre

#
'''TABLE OF CONTENTS: '''
#

# 1.) MODULES
#     - import all modules needed in file
#
# 2.) CONSTANTS AND PARAMETERS
#     - establish constants and set parameters that don't change over the course of the calculation
#
# 3.) TEXTFILES TO SAVE RESULTS
#     - create textfiles for results of calculation and write column headers
#
# 4.) VARIABLE PARAMETERS
#     - define parameters and functions that change over the course of the calculation
#
# 5.) ARRAYS FOR RESULTS
#     - define arrays to filtered results into
#
# 6.) INITIAL CONDITIONS
#     - read out initial conditions from 'RNG_initial_conditions.txt' and
#       get the initial position and velocity vectors, and the initial time from it
#
# 7.) MAIN CALCULATION
#     - define arrays for intermediate results from every step
#     - define differential equations in function 'diff_eq'
#     - generate list of solutions 'sol' with ODEint
#     - 'sol' is a list of the position and velocity of one HVS at every time step of the simulation
#
# 8.) FILTERING OF RESULTS
#     - get the values at t_0 = 13.8Gyrs and writing them into the result arrays from Sec. 4.)
#     - apply first filter step of d_MW < 50kpc
#
# 9.) TRANSFORMATION TO GALACTIC CARTESIAN COORDINATES
#     - on both position and velocity vector:
#     - perform shift of origin to the Sun
#     - perform two coordinate rotations to align axes with Gal. Cart. coordinates
#     - boost velocity vectors to heliocentric rest frame
#
# 10.) TRANSFORMATION TO GALACTIC COORDINATES
#     - transform to Galactic coordinates with spherical transformation
#     - read data into a Skycoord array for plotting and transformation to equatorial coordinates
#
# 11.) WRITE FINAL RESULTS INTO DATA FILE
#     - write into results file: distance to the Sun, time, Galactic coordinates of HVS,
#       RA/DEC of HVS, velocity magnitude, Cartesian velocity components, Galactic velocity direction coordinates


# Modules

# First import some modules
# import matplotlib.pyplot as plt
import numpy as np
from scipy.integrate import odeint
from scipy.interpolate import interp1d
import sys
from astropy.coordinates import SkyCoord


#
'''CONSTANTS AND PARAMETERS: '''
#

# filter threshold for distance to the MW centre [kpc]
filter = 50

# age of the universe [Myrs]
t_0 = 13800

# length of time interval
time_steps = 10001

# rescaled grav. constant [kpc^3/(Myr^2 * M_o)]
G = 4.49948902 * 10 ** (-12)

# concentration parameter
c = 10

# Milky Way scale radius for NFW dark matter profile [kpc]
R_s1 = 20.

# Andromeda scale radius for NFW dark matter profile [kpc]
R_s2 = 20.  # Andromeda scale radius for NFW dark matter profile [kpc]

# Plummer radius of galaxies for Plummer term in differential eq., considers only baryonic matter [kpc]
a = 4

# dark matter density off halo at scale radius [M_o/kpc^3] (for R_s = 20kpc and M = 1/2 * 5/6 * M_LG)
rho_0 = 1.172377895 * 10 ** 7

# total masses of each galaxy [M_o]
M_MW = 0.8 * 10 ** 12  # mass of the Milky Way
M_AND = 0.8 * 10 ** 12  # mass of Andromeda

# 1st variant for mass
# M_MW = 0.615 * 10 ** 12  # mass of the Milky Way
# M_AND = 1.13888888888 * 10 ** 12  # mass of Andromeda

# baryonic masses of the two galaxies
M1 = M_MW / 6
M2 = M_AND / 6

# rho_0 if the MW and Andromeda masses are different
rho_0_MW = (5 / 6) * (M_MW / (4 * np.pi * (R_s1 ** 3))) * \
    (np.log(1 + c) - (c / (1 + c))) ** (-1)

rho_0_AND = (5 / 6) * (M_AND / (4 * np.pi * (R_s2 ** 3))) * \
    (np.log(1 + c) - (c / (1 + c))) ** (-1)

# print(rho_0_AND)

# position of the Sun in Kartesian coordinate system centered on MW centre
r_Sun = [4.003551, 7.13161944, 0.]

# velocity vector of the sun in the Milky Way rest frame (in Galactic Kartesian coordinates) [km/s]
sun_vel = [11.1, 12.24 + 240, 7.25]

# transformation constant (kpc/Myr -> km/s)
trafo = 1000 / 1.023

# both of these angles at present time:
# angle between (simulation) x-axis and MW galactic coordinate (0,0)-axis [rad]
epsilon = 2.08233

# angle between simulation x-y-plane and MW galactic plane [rad]
phi = -0.4328320437

# rotation matrices for coordinate transformation at the end
# rotation matrix for rotation around z-axis
Rot_z = np.array([[np.cos(epsilon), np.sin(epsilon) * (-1), 0],
                  [np.sin(epsilon), np.cos(epsilon), 0], [0, 0, 1]])

# rotation matrix for rotation around x-axis
Rot_x = np.array([[1, 0, 0], [0, np.cos(phi), np.sin(phi) * (-1)],
                  [0, np.sin(phi), np.cos(phi)]])


#
'''TEXTFILES TO SAVE RESULTS: '''
#

# save all distances to the Sun in a textfile + save all really small min. distances in a separate file
np.savetxt("all-min-distances-to-sun.txt", [])
np.savetxt("present-time-distances.txt", [])
np.savetxt("minimum-distances-to-sun.txt", [])

all = open("all-min-distances-to-sun.txt", "w")
present = open("present-time-distances.txt", "w")
minimum = open("minimum-distances-to-sun.txt", "w")

# write column headers into each first line
all.write("# Minimum_distance_to_Sun[kpc]" + " " + "\n")
# write column headers
present.write("# Present_dist_to_MW[kpc]" + " " + "Present_dist_to_Sun[kpc]" + " " + "Time[Myr]" + " " + "Init_Time[Myr]" + " " + "Gal_long[deg]" + " " + "Gal_lat[deg]" + " " + "x[kpc]" + " " + "y[kpc]" + " " +
              "z[kpc]" + " " + "vx[kpc/Myr]" + " " + "vy[kpc/Myr]" + " " + "vz[kpc/Myr]" + " " + "Init_x[kpc]" + " " + "Init_y[kpc]" + " " + "Init_z[kpc]" + " " + "Init_vel_mag[kpc/Myr]" + " " + "Init_vx[kpc/Myr]" + " " + "Init_vy[kpc/Myr]" + " " + "Init_vz[kpc/Myr]" + "\n")
# filler line
minimum.write("# Min_dist_to_MW[kpc]" + " " + "Corr_dist_to_Sun[kpc]" + " " + "Time[Myr]" + " " + "Init_Time[Myr]" + " " + "Gal_long[deg]" + " " + "Gal_lat[deg]" + " " + "x[kpc]" + " " + "y[kpc]" + " " +
              "z[kpc]" + " " + "vx[kpc/Myr]" + " " + "vy[kpc/Myr]" + " " + "vz[kpc/Myr]" + " " + "Init_x[kpc]" + " " + "Init_y[kpc]" + " " + "Init_z[kpc]" + " " + "Init_vel_mag[kpc/Myr]" + " " + "Init_vx[kpc/Myr]" + " " + "Init_vy[kpc/Myr]" + " " + "Init_vz[kpc/Myr]" + "\n")


#
'''VARIABLE PARAMETERS: '''
#

# Read the data of the movement of Andromeda from data file
# readout1 = np.loadtxt('/home/lguelzow/same-mass/M31-trajectory-same-mass.txt', dtype=np.str)
readout1 = np.loadtxt('/home/lguelzow/paper_update/On-Stellar-Migration-from-the-Andromeda-Galaxy/simulation-code/M31-trajectory.txt', dtype=np.str)
# option for HPC array and the specific filesystem
# readout1 = np.loadtxt('/upb/departments/pc2/users/h/hypvel02/Python_files/new_test/M31-position.txt', dtype=np.str)


# Convert the whole table into an array of strings
# call: readout variable
M31_array = np.array(readout1)

# print(len(M31_array))

# List of time steps in the Andromeda table
# use List comprehension to get the time values from the readout variable and convert the strings into floats
t_M31 = [float(M31_array[x + 1, 0]) for x in range(len(M31_array) - 1)]


# readout Andromeda position from readout variable
# List comprehensions to get arrays for components of Andromeda position and velocity vectors
# x, y and z components

# Get the x values from the big table and convert the strings into floats
x_Andr = [float(M31_array[x + 1, 1]) for x in range(len(M31_array) - 1)]

# Get the y values from the big table and convert the strings into floats
y_Andr = [float(M31_array[x + 1, 2]) for x in range(len(M31_array) - 1)]

# Get the z values from the big table and convert the strings into floats
z_Andr = [float(M31_array[x + 1, 3]) for x in range(len(M31_array) - 1)]

# x, y and z components of the velocity
# Get the x-direction velocity values from the big table and convert the strings into floats
vx_Andr = [float(M31_array[x + 1, 4]) for x in range(len(M31_array) - 1)]

# Get the y-direction velocity values from the big table and convert the strings into floats
vy_Andr = [float(M31_array[x + 1, 5]) for x in range(len(M31_array) - 1)]

# Get the z-direction velocity values from the big table and convert the strings into floats
vz_Andr = [float(M31_array[x + 1, 6]) for x in range(len(M31_array) - 1)]


# interpolate the position and velocity arrays into continuous functions of ttime with interp1D
A_xfunc = interp1d(t_M31, x_Andr, bounds_error=False, fill_value="extrapolate")

A_yfunc = interp1d(t_M31, y_Andr, bounds_error=False, fill_value="extrapolate")

A_zfunc = interp1d(t_M31, z_Andr, bounds_error=False, fill_value="extrapolate")


# repeat for the velocities
A_vxfunc = interp1d(t_M31, vx_Andr, bounds_error=False,
                    fill_value="extrapolate")

A_vyfunc = interp1d(t_M31, vy_Andr, bounds_error=False,
                    fill_value="extrapolate")

A_vzfunc = interp1d(t_M31, vz_Andr, bounds_error=False,
                    fill_value="extrapolate")

# print(A_vxfunc(10000))

# plt.plot(A_xfunc(t))
# plt.show()


#
'''ARRAYS FOR RESULTS: '''
#

# Read out the randomly generated initial conditions from text file
# here and not in the initial conditions section because we need the amount
# of initial conditions for the length of the result arrays
readout2 = np.loadtxt('HVS-initial-conditions.txt', dtype=np.str)

# convert the readout into an array of strings
# conversion to floats is in the for-loop
ini = np.array(readout2)

# base arrays on amount of initial conditions
# array of minimum distances to the Sun in every timestep
min_D = [None] * (len(ini) - 1)

# array to store minimum distance to MW_centre
min_D_dist = []

# array to store corresponding distance to Sun
min_D_dist_sun = []

# array to store the position coordinates of the star at its minimum distance to the sun
min_D_coord = []

# array for time the star reached minimum distance
min_D_time = []

# array for velocity magnitude
min_D_mag_vel = []

# array for velocity vector components
min_D_vel = []

# array for initial conditions
min_D_ICs = []


# second set of result arrays
# array to store minimum distance to MW_centre
t0_dist = []

# array to store corresponding distance to Sun
t0_dist_sun = []

# array to store the position coordinates of the star at its minimum distance to the sun
t0_coord = []

# array for time the star reached minimum distance
t0_time = []

# array for velocity magnitude
t0_mag_vel = []

# array for velocity vector components
t0_vel = []

# array for initial conditions
t0_ICs = []


#
'''INITIAL CONDITIONS: '''
#

print("\nStarting loop to calculate trajectories...\n")

# for-loop to let the code run as many times as there are initial conditions
for i in range(len(ini) - 1):

    # display progress of calculation on command line
    if i % 100 == 0:
        sys.stdout.write(
            "\rProgress:" + str(float(i) / (len(ini) - 1)))
        sys.stdout.flush()

    # process the randomly generated initial conditions
    # and generate the time frame of the calculation
    # and find the initial position and velocity vector

    # get the initial send-off time and generate the time array for ODEint from it
    t_ini = float(ini[i + 1, 0])

    # define time interval from randomly generated initial time
    t = np.linspace(t_ini, t_0, time_steps)

    # print(len(t))

    # write the initial distance values into a list and convert them back to floats
    r0 = [float(ini[i + 1, x + 1]) for x in range(3)]

    # print(r0)

    # write the initial velocity values into an array and convert them back to floats
    v0 = [float(ini[i + 1, x + 4]) for x in range(3)]

    # keep unaltered initial conditions for result file
    ini_pos = [r0[0], r0[1], r0[2]]

    ini_vel = [v0[0], v0[1], v0[2]]

    ini_vel_mag = (v0[0] ** 2 + v0[1] ** 2 + v0[2] ** 2) ** 0.5

    # print(v0)

    # add Andromeda's initial position from the arrays to test star initial position
    # to get the complete initial HVS position vector [kpc]
    r0[0] += A_xfunc(t_ini)
    r0[1] += A_yfunc(t_ini)
    r0[2] += A_zfunc(t_ini)

    # print(r0)

    # add initial velocity of Andromeda to HVS initial velocity [kpc/Myr]
    v0[0] += A_vxfunc(t_ini)
    v0[1] += A_vyfunc(t_ini)
    v0[2] += A_vzfunc(t_ini)

    # print(v0)

    # build HVS initial vectors out of readout variable initial conditions[(r[kpc], v[kpc/Myr])]
    y0 = [r0[0], v0[0], r0[1], v0[1], r0[2], v0[2]]

    # print(y0)

    #
    '''MAIN CALCULATION:'''
    #

    # Define the vector y = [r, v] which will be our solution and a time interval
    #
    # Then diff_eq returns a vector of the derivatives dydt = [r'(t), v'(t)]
    #
    # Solve the six DEs simultaneously with ODEint

    def diff_eq(y0, t, G, R_s1, R_s2, M1, M2):
        # Unpack the vector y = [rx, vx, ry, vy, rz, vz]
        rx, vx, ry, vy, rz, vz = y0

        # magnitude of distance and velocity vector to Milky Way
        mag_r = (rx ** 2 + ry ** 2 + rz ** 2) ** 0.5
        # mag_v = (vx ** 2 + vy ** 2 + vz ** 2) ** 0.5

        # magnitude of distance vector to Andromeda
        mag_andr = ((rx - A_xfunc(t)) ** 2 +
                    (ry - A_yfunc(t)) ** 2 + (rz - A_zfunc(t)) ** 2) ** 0.5

       # calculate differential equations [v_i, a_i]
        dy1dt = [vx, 4 * np.pi * G * (rho_0_MW * R_s1 ** 3 * (mag_r / (R_s1 + mag_r) - np.log((R_s1 + mag_r) / R_s1)) * rx / (mag_r ** 3) + rho_0_AND * R_s2 ** 3 * (mag_andr / (R_s2 + mag_andr) - np.log(
            (R_s2 + mag_andr) / R_s2)) * (rx - A_xfunc(t)) / (mag_andr) ** 3 - M1 * rx / (4 * np.pi * (mag_r ** 2 + a ** 2) ** 1.5) - M2 * (rx - A_xfunc(t)) / (4 * np.pi * (mag_andr ** 2 + a ** 2) ** 1.5))]
        # print(dy1dt)

        dy2dt = [vy, 4 * np.pi * G * (rho_0_MW * R_s1 ** 3 * (mag_r / (R_s1 + mag_r) - np.log((R_s1 + mag_r) / R_s1)) * ry / (mag_r ** 3) + rho_0_AND * R_s2 ** 3 * (mag_andr / (R_s2 + mag_andr) - np.log(
            (R_s2 + mag_andr) / R_s2)) * (ry - A_yfunc(t)) / (mag_andr) ** 3 - M1 * ry / (4 * np.pi * (mag_r ** 2 + a ** 2) ** 1.5) - M2 * (ry - A_yfunc(t)) / (4 * np.pi * (mag_andr ** 2 + a ** 2) ** 1.5))]
        # print(dy2dt)

        dy3dt = [vz, 4 * np.pi * G * (rho_0_MW * R_s1 ** 3 * (mag_r / (R_s1 + mag_r) - np.log((R_s1 + mag_r) / R_s1)) * rz / (mag_r ** 3) + rho_0_AND * R_s2 ** 3 * (mag_andr / (R_s2 + mag_andr) - np.log(
            (R_s2 + mag_andr) / R_s2)) * (rz - A_zfunc(t)) / (mag_andr) ** 3 - M1 * rz / (4 * np.pi * (mag_r ** 2 + a ** 2) ** 1.5) - M2 * (rz - A_zfunc(t)) / (4 * np.pi * (mag_andr ** 2 + a ** 2) ** 1.5))]
        # print(dy3dt)DE

        return dy1dt + dy2dt + dy3dt

    # Finally find the solution using scipy.odeint
    sol = odeint(diff_eq, y0, t, args=(G, R_s1, R_s2, M1, M2))
    # This gives a (len(t), 6) array with the columns corresponding to [rx, vx, ry, vy, rz, vz]

    #
    '''FILTERING OF RESULTS: '''
    #

    # last time step
    t_last = time_steps - 1

    # define distance at present time to compare to filter criterium for distance to MW centre
    present_time_filter_dist = (sol[t_last][0] ** 2 + sol[t_last]
                                [2] ** 2 + sol[t_last][4] ** 2) ** 0.5

    # print(sun_filter_dist)
    # print(t[time_steps - 1])

    # list for distance to the MW_centre in every timestep
    distance_list = [((sol[x][0]) ** 2 + (sol[x][2]) ** 2 + (sol[x][4]) ** 2) ** 0.5
                     for x in range(time_steps)]

    # find the minimum distance for each iteration and write it into the corresponding array
    min_D[i] = np.amin(distance_list)

    # and write minimum distance to Sun into data file
    all.write(str(min_D[i]) + " " + "\n")

    # filter for stars that come with 50kpc of the Milky Way centre at any time in the simulation
    # then append eligible results to result arrays
    if min_D[i] < filter:
        # write distance to MW centre into array
        min_D_dist.append(min_D[i])

        # write corresponding distance to the Sun into array
        min_D_dist_sun.append(((sol[np.argmin(distance_list)][0] - r_Sun[0]) ** 2 + (sol[np.argmin(
            distance_list)][2] - r_Sun[1]) ** 2 + (sol[np.argmin(distance_list)][4] - r_Sun[2]) ** 2) ** 0.5)

        # write time of minimum distance into array
        min_D_time.append(t[np.argmin(distance_list)])

        # write position of minimum distance into corresponding array
        min_D_coord.append([sol[np.argmin(distance_list)][0], sol[np.argmin(
            distance_list)][2], sol[np.argmin(distance_list)][4]])

        # write velocity magnitude into list
        min_D_mag_vel.append((sol[np.argmin(distance_list)][1] ** 2 + sol[np.argmin(distance_list)][3]
                              ** 2 + sol[np.argmin(distance_list)][5] ** 2) ** 0.5)

        # write velocity components into array
        min_D_vel.append([sol[np.argmin(distance_list)][1], sol[np.argmin(
            distance_list)][3], sol[np.argmin(distance_list)][5]])

        # write initial conditions into array
        min_D_ICs.append([t_ini, ini_pos[0], ini_pos[1], ini_pos[2],
                          ini_vel_mag, ini_vel[0], ini_vel[1], ini_vel[2]])

    # filter for stars that are r =< 50kpc to the MW centre at t0 = 13.8Gyrs
    # then append eligible entries to the sub50 result arrays
    if present_time_filter_dist < filter:

        # write distance to MW centre into array
        t0_dist.append(present_time_filter_dist)

        # write corresponding distance to the Sun into array
        t0_dist_sun.append(((sol[t_last][0] - r_Sun[0]) ** 2 + (sol[t_last][2] - r_Sun[1]) ** 2
                                                             + (sol[t_last][4] - r_Sun[2]) ** 2) ** 0.5)

        # write time of minimum distance into array
        t0_time.append(t[t_last])

        # write position of minimum distance into corresponding array
        t0_coord.append([sol[t_last][0], sol[t_last][2], sol[t_last][4]])

        # write velocity magnitude into list
        t0_mag_vel.append((sol[t_last][1] ** 2 + sol[t_last][3] ** 2
                                               + sol[t_last][5] ** 2) ** 0.5)

        # write velocity components into array
        t0_vel.append([sol[t_last][1], sol[t_last][3], sol[t_last][5]])

        # write initial conditions into array
        t0_ICs.append([t_ini, ini_pos[0], ini_pos[1], ini_pos[2],
                       ini_vel_mag, ini_vel[0], ini_vel[1], ini_vel[2]])


# print(t0_coord)
# print(sub_50_coord)


#
'''TRANSFORMATION TO GALACTIC CARTESIAN COORDINATES'''
#

print("\n \nProcessing results...\n")


# transform present coordinates to coordinates relative to the Sun
min_D_coord = [[min_D_coord[i][0] - r_Sun[0],
                min_D_coord[i][1] - r_Sun[1], min_D_coord[i][2] - r_Sun[2]] for i in range(len(min_D_coord))]

t0_coord = [[t0_coord[i][0] - r_Sun[0],
             t0_coord[i][1] - r_Sun[1], t0_coord[i][2] - r_Sun[2]] for i in range(len(t0_coord))]


# print(t0_coord)
# print(sub_50_coord)


#
# transform the results from both lists to Galactic Cartesian coordinates and then to RA/DEC with these steps
#

# rotate the katesian coordinate system so that the MW centre is at y = z = 0 and x > 0
for i in range(len(min_D_coord)):
    # first for the minimum distance to the Sun results
    min_D_coord[i] = np.dot(Rot_z, min_D_coord[i])
    min_D_coord[i] = np.dot(Rot_x, min_D_coord[i])

    # then do the same thing for the velocities
    min_D_vel[i] = np.dot(Rot_z, min_D_vel[i])
    min_D_vel[i] = np.dot(Rot_x, min_D_vel[i])


# separate loops because length will be different
for i in range(len(t0_coord)):
    # then for the t0 results
    t0_coord[i] = np.dot(Rot_z, t0_coord[i])
    t0_coord[i] = np.dot(Rot_x, t0_coord[i])

    # then do the same thing for the velocities
    t0_vel[i] = np.dot(Rot_z, t0_vel[i])
    t0_vel[i] = np.dot(Rot_x, t0_vel[i])


# transform from Milky Way rest frame to heliocentric rest frame by adding sun velocity vector to star velocity vector
# first for the min_D results
min_D_vel = [[min_D_vel[i][0] - (sun_vel[0] / trafo), min_D_vel[i][1] - (
    sun_vel[1] / trafo), min_D_vel[i][2] - (sun_vel[2] / trafo)] for i in range(len(min_D_vel))]

# also calculate new velocity magnitude
min_D_mag_vel = [(min_D_vel[i][0] ** 2 +
                  min_D_vel[i][1] ** 2 + min_D_vel[i][2] ** 2) ** 0.5 for i in range(len(min_D_mag_vel))]

# and then for the t0 results
t0_vel = [[t0_vel[i][0] - (sun_vel[0] / trafo), t0_vel[i][1] - (
    sun_vel[1] / trafo), t0_vel[i][2] - (sun_vel[2] / trafo)] for i in range(len(t0_vel))]

# also calculate new velocity magnitude
t0_mag_vel = [(t0_vel[i][0] ** 2 +
               t0_vel[i][1] ** 2 + t0_vel[i][2] ** 2) ** 0.5 for i in range(len(t0_mag_vel))]

# print(t0_mag_vel)
# print(sub_50_mag_vel)


# write results into secondary results file for sub_50 data
# present.write(str(sub_50_sun_distance[i]) + " " + str(sub_50_t[i]) + " " + str(sub_50_mag_vel[i]) + " " + str(sub_50_vel[i][0]) + " " + str(sub_50_vel[i][1]) + " " + str(sub_50_vel[i][2]) + " " + str(sub_50_ini_vel[i]) + " " + str(sub_50_ini_time[i]) + " " + "\n")


#
'''TRANSFORMATION TO GALACTIC COORDINATES:'''
#

# define galactic coordinate array with [gal. longitude, gal.latitude] and ICRS array with [RA, Dec]

# minimum distances first
# transform Galactic Cartesian system to spherical coordinates without radius = Galactic coordinates
min_D_gal_coord = [[np.arctan2(min_D_coord[i][1], min_D_coord[i][0]) * (180 / np.pi), np.arcsin(
    min_D_coord[i][2] / min_D_dist_sun[i]) * (180 / np.pi)] for i in range(len(min_D_coord))]

# make separate arrays for l and b for easier plotting
min_D_gal_l = [np.arctan2(min_D_coord[i][1], min_D_coord[i][0])
               * (180 / np.pi) for i in range(len(min_D_coord))]

min_D_gal_b = [np.arcsin(min_D_coord[i][2] / min_D_dist_sun[i])
               * (180 / np.pi) for i in range(len(min_D_coord))]


# then t0 distances
# transform Galactic Cartesian system to spherical coordinates without radius = Galactic coordinates
t0_gal_coord = [[np.arctan2(t0_coord[i][1], t0_coord[i][0]) * (180 / np.pi), np.arcsin(
    t0_coord[i][2] / t0_dist_sun[i]) * (180 / np.pi)] for i in range(len(t0_coord))]

# make separate arrays for l and b for easier plotting
t0_gal_l = [np.arctan2(t0_coord[i][1], t0_coord[i][0])
            * (180 / np.pi) for i in range(len(t0_coord))]

t0_gal_b = [np.arcsin(t0_coord[i][2] / t0_dist_sun[i]) *
            (180 / np.pi) for i in range(len(t0_coord))]


# print(t0_gal_coord)
# print(gal_coord)


# print(gal_coord)

min_D_gal = SkyCoord(
    min_D_gal_l[:], min_D_gal_b[:], frame="galactic", unit="deg")
t0_gal = SkyCoord(t0_gal_l[:], t0_gal_b[:], frame="galactic", unit="deg")

# print(gal)
# print(t0_gal)


min_D_RA_dec_coord = min_D_gal.icrs

t0_RA_dec_coord = t0_gal.icrs

# print(t0_RA_dec_coord[0].to_string('hmsdms'))
# print(i)


#
'''WRITE FINAL RESULTS INTO FILES:'''
#

# print the number of min distances below 50kpc compared to below 15kpc
print("\n" + "Number of HVS closer than 50kpc to the MW centre at any time:\n" +
      str(len(min_D_coord)))
print("\nNumber of HVS closer than 50kpc to the MW centre at t0 = 13800 Myrs:\n" + str(len(t0_coord)))

# print(sub_200)

# write all results for minimum distances to the MW centre into MINIMUM results file
for i in range(len(min_D_coord)):
    minimum.write(str(min_D_dist[i]) + " " + str(min_D_dist_sun[i]) + " " + str(min_D_time[i]) + " " + str(min_D_ICs[i][0]) + " "
                  + str(min_D_gal_coord[i][0]) + " " + str(min_D_gal_coord[i][1]) +
                  " " + str(min_D_coord[i][0]) + " " +
                  str(min_D_coord[i][1]) + " "
                  + str(min_D_coord[i][2]) + " " + str(min_D_vel[i][0]) + " " +
                  str(min_D_vel[i][1]) + " " + str(min_D_vel[i][2]) + " "
                  + str(min_D_ICs[i][1]) + " " + str(min_D_ICs[i]
                                                     [2]) + " " + str(min_D_ICs[i][3]) + " "
                  + str(min_D_ICs[i][4]) + " " + str(min_D_ICs[i][5]) + " " + str(min_D_ICs[i][6]) + " " + str(min_D_ICs[i][7]) + "\n")


# write all results for distances to the MW centre at t0 into present results file
# line 1: times, distances and positions
# line 2: velocity magnitude and components
# line 3: initial position
# line 4: initial velocity magnitude and components
for i in range(len(t0_coord)):
    present.write(str(t0_dist[i]) + " " + str(t0_dist_sun[i]) + " " + str(t0_time[i]) + " " + str(t0_ICs[i][0]) + " "
                  + str(t0_gal_coord[i][0]) + " " + str(t0_gal_coord[i][1]) + " " + str(t0_coord[i][0]) + " " + str(t0_coord[i][1]) + " " + str(t0_coord[i][2]) + " " + str(t0_vel[i][0]) + " " +
                  str(t0_vel[i][1]) + " " + str(t0_vel[i][2]) + " "
                  + str(t0_ICs[i][1]) + " " + str(t0_ICs[i][2]) +
                  " " + str(t0_ICs[i][3]) + " "
                  + str(t0_ICs[i][4]) + " " + str(t0_ICs[i][5]) + " " + str(t0_ICs[i][6]) + " " + str(t0_ICs[i][7]) + "\n")
